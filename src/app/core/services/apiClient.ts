//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class APIClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CinemaDTOIEnumerableAPIResponse> {
        let url_ = this.baseUrl + "/api/Cinema/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CinemaDTOIEnumerableAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CinemaDTOIEnumerableAPIResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CinemaDTOIEnumerableAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CinemaDTOIEnumerableAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CinemaDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/Cinema/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CinemaDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CinemaDTOAPIResponse>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CinemaDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CinemaDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: CinemaDTO | undefined): Observable<CinemaDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/Cinema/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CinemaDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CinemaDTOAPIResponse>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<CinemaDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CinemaDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CinemaDTO | undefined): Observable<CinemaDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/Cinema/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CinemaDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CinemaDTOAPIResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CinemaDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CinemaDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteById(id: number | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Cinema/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body: CinemaDTO | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Cinema/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll2(): Observable<GenreDTOIEnumerableAPIResponse> {
        let url_ = this.baseUrl + "/api/Genre/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenreDTOIEnumerableAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenreDTOIEnumerableAPIResponse>;
        }));
    }

    protected processGetAll2(response: HttpResponseBase): Observable<GenreDTOIEnumerableAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenreDTOIEnumerableAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById2(id: number | undefined): Observable<GenreDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/Genre/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenreDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenreDTOAPIResponse>;
        }));
    }

    protected processGetById2(response: HttpResponseBase): Observable<GenreDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenreDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add2(body: GenreDTO | undefined): Observable<GenreDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/Genre/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenreDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenreDTOAPIResponse>;
        }));
    }

    protected processAdd2(response: HttpResponseBase): Observable<GenreDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenreDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update2(body: GenreDTO | undefined): Observable<GenreDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/Genre/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenreDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenreDTOAPIResponse>;
        }));
    }

    protected processUpdate2(response: HttpResponseBase): Observable<GenreDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenreDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteById2(id: number | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Genre/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDeleteById2(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete2(body: GenreDTO | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Genre/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDelete2(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    getMovieByName(name: string | undefined): Observable<MovieDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Movie/GetMovieByName?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMovieByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMovieByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MovieDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MovieDtoAPIResponse>;
        }));
    }

    protected processGetMovieByName(response: HttpResponseBase): Observable<MovieDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MovieDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll3(): Observable<MovieDtoIEnumerableAPIResponse> {
        let url_ = this.baseUrl + "/api/Movie/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MovieDtoIEnumerableAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MovieDtoIEnumerableAPIResponse>;
        }));
    }

    protected processGetAll3(response: HttpResponseBase): Observable<MovieDtoIEnumerableAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MovieDtoIEnumerableAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById3(id: number | undefined): Observable<MovieDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Movie/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MovieDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MovieDtoAPIResponse>;
        }));
    }

    protected processGetById3(response: HttpResponseBase): Observable<MovieDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MovieDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add3(body: MovieDto | undefined): Observable<MovieDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Movie/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MovieDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MovieDtoAPIResponse>;
        }));
    }

    protected processAdd3(response: HttpResponseBase): Observable<MovieDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MovieDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update3(body: MovieDto | undefined): Observable<MovieDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Movie/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MovieDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MovieDtoAPIResponse>;
        }));
    }

    protected processUpdate3(response: HttpResponseBase): Observable<MovieDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MovieDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteById3(id: number | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Movie/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDeleteById3(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete3(body: MovieDto | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Movie/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDelete3(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll4(): Observable<PaymentDTOIEnumerableAPIResponse> {
        let url_ = this.baseUrl + "/api/Payment/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentDTOIEnumerableAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentDTOIEnumerableAPIResponse>;
        }));
    }

    protected processGetAll4(response: HttpResponseBase): Observable<PaymentDTOIEnumerableAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDTOIEnumerableAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById4(id: number | undefined): Observable<PaymentDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/Payment/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentDTOAPIResponse>;
        }));
    }

    protected processGetById4(response: HttpResponseBase): Observable<PaymentDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add4(body: PaymentDTO | undefined): Observable<PaymentDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/Payment/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentDTOAPIResponse>;
        }));
    }

    protected processAdd4(response: HttpResponseBase): Observable<PaymentDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update4(body: PaymentDTO | undefined): Observable<PaymentDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/Payment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentDTOAPIResponse>;
        }));
    }

    protected processUpdate4(response: HttpResponseBase): Observable<PaymentDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteById4(id: number | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Payment/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDeleteById4(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete4(body: PaymentDTO | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Payment/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete4(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDelete4(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll5(): Observable<ReviewDtoIEnumerableAPIResponse> {
        let url_ = this.baseUrl + "/api/Review/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDtoIEnumerableAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDtoIEnumerableAPIResponse>;
        }));
    }

    protected processGetAll5(response: HttpResponseBase): Observable<ReviewDtoIEnumerableAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDtoIEnumerableAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById5(id: number | undefined): Observable<ReviewDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Review/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDtoAPIResponse>;
        }));
    }

    protected processGetById5(response: HttpResponseBase): Observable<ReviewDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add5(body: ReviewDto | undefined): Observable<ReviewDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Review/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDtoAPIResponse>;
        }));
    }

    protected processAdd5(response: HttpResponseBase): Observable<ReviewDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update5(body: ReviewDto | undefined): Observable<ReviewDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Review/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReviewDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReviewDtoAPIResponse>;
        }));
    }

    protected processUpdate5(response: HttpResponseBase): Observable<ReviewDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteById5(id: number | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Review/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDeleteById5(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete5(body: ReviewDto | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Review/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete5(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDelete5(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll6(): Observable<RoleDtoIEnumerableAPIResponse> {
        let url_ = this.baseUrl + "/api/Role/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoIEnumerableAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoIEnumerableAPIResponse>;
        }));
    }

    protected processGetAll6(response: HttpResponseBase): Observable<RoleDtoIEnumerableAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoIEnumerableAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById6(id: number | undefined): Observable<RoleDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Role/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoAPIResponse>;
        }));
    }

    protected processGetById6(response: HttpResponseBase): Observable<RoleDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add6(body: RoleDto | undefined): Observable<RoleDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Role/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoAPIResponse>;
        }));
    }

    protected processAdd6(response: HttpResponseBase): Observable<RoleDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update6(body: RoleDto | undefined): Observable<RoleDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoAPIResponse>;
        }));
    }

    protected processUpdate6(response: HttpResponseBase): Observable<RoleDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteById6(id: number | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Role/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDeleteById6(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete6(body: RoleDto | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Role/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete6(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDelete6(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll7(): Observable<ShowTimeDTOIEnumerableAPIResponse> {
        let url_ = this.baseUrl + "/api/ShowTime/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShowTimeDTOIEnumerableAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShowTimeDTOIEnumerableAPIResponse>;
        }));
    }

    protected processGetAll7(response: HttpResponseBase): Observable<ShowTimeDTOIEnumerableAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShowTimeDTOIEnumerableAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById7(id: number | undefined): Observable<ShowTimeDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/ShowTime/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShowTimeDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShowTimeDTOAPIResponse>;
        }));
    }

    protected processGetById7(response: HttpResponseBase): Observable<ShowTimeDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShowTimeDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add7(body: ShowTimeDTO | undefined): Observable<ShowTimeDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/ShowTime/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShowTimeDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShowTimeDTOAPIResponse>;
        }));
    }

    protected processAdd7(response: HttpResponseBase): Observable<ShowTimeDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShowTimeDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update7(body: ShowTimeDTO | undefined): Observable<ShowTimeDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/ShowTime/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShowTimeDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShowTimeDTOAPIResponse>;
        }));
    }

    protected processUpdate7(response: HttpResponseBase): Observable<ShowTimeDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShowTimeDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteById7(id: number | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/ShowTime/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDeleteById7(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete7(body: ShowTimeDTO | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/ShowTime/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete7(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDelete7(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll8(): Observable<TicketDtoIEnumerableAPIResponse> {
        let url_ = this.baseUrl + "/api/Ticket/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketDtoIEnumerableAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketDtoIEnumerableAPIResponse>;
        }));
    }

    protected processGetAll8(response: HttpResponseBase): Observable<TicketDtoIEnumerableAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoIEnumerableAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById8(id: number | undefined): Observable<TicketDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Ticket/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketDtoAPIResponse>;
        }));
    }

    protected processGetById8(response: HttpResponseBase): Observable<TicketDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add8(body: TicketDto | undefined): Observable<TicketDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Ticket/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketDtoAPIResponse>;
        }));
    }

    protected processAdd8(response: HttpResponseBase): Observable<TicketDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update8(body: TicketDto | undefined): Observable<TicketDtoAPIResponse> {
        let url_ = this.baseUrl + "/api/Ticket/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TicketDtoAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TicketDtoAPIResponse>;
        }));
    }

    protected processUpdate8(response: HttpResponseBase): Observable<TicketDtoAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketDtoAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteById8(id: number | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Ticket/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDeleteById8(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete8(body: TicketDto | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/Ticket/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete8(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDelete8(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: UserRequestDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll9(): Observable<UserDTOIEnumerableAPIResponse> {
        let url_ = this.baseUrl + "/api/User/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTOIEnumerableAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTOIEnumerableAPIResponse>;
        }));
    }

    protected processGetAll9(response: HttpResponseBase): Observable<UserDTOIEnumerableAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTOIEnumerableAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById9(id: number | undefined): Observable<UserDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/User/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTOAPIResponse>;
        }));
    }

    protected processGetById9(response: HttpResponseBase): Observable<UserDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add9(body: UserDTO | undefined): Observable<UserDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/User/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTOAPIResponse>;
        }));
    }

    protected processAdd9(response: HttpResponseBase): Observable<UserDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update9(body: UserDTO | undefined): Observable<UserDTOAPIResponse> {
        let url_ = this.baseUrl + "/api/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDTOAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDTOAPIResponse>;
        }));
    }

    protected processUpdate9(response: HttpResponseBase): Observable<UserDTOAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDTOAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteById9(id: number | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/User/DeleteById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDeleteById9(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete9(body: UserDTO | undefined): Observable<BooleanAPIResponse> {
        let url_ = this.baseUrl + "/api/User/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete9(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanAPIResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanAPIResponse>;
        }));
    }

    protected processDelete9(response: HttpResponseBase): Observable<BooleanAPIResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanAPIResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class BooleanAPIResponse implements IBooleanAPIResponse {
    success?: boolean;
    data?: boolean;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IBooleanAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] !== undefined ? _data["data"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): BooleanAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data !== undefined ? this.data : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IBooleanAPIResponse {
    success?: boolean;
    data?: boolean;
    message?: string | null;
    errorMessage?: string | null;
}

export class CinemaDTO implements ICinemaDTO {
    cinemaId?: number;
    name?: string | null;
    location?: string | null;
    contactInfo?: string | null;

    constructor(data?: ICinemaDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cinemaId = _data["cinemaId"] !== undefined ? _data["cinemaId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.location = _data["location"] !== undefined ? _data["location"] : <any>null;
            this.contactInfo = _data["contactInfo"] !== undefined ? _data["contactInfo"] : <any>null;
        }
    }

    static fromJS(data: any): CinemaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CinemaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cinemaId"] = this.cinemaId !== undefined ? this.cinemaId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        data["contactInfo"] = this.contactInfo !== undefined ? this.contactInfo : <any>null;
        return data;
    }
}

export interface ICinemaDTO {
    cinemaId?: number;
    name?: string | null;
    location?: string | null;
    contactInfo?: string | null;
}

export class CinemaDTOAPIResponse implements ICinemaDTOAPIResponse {
    success?: boolean;
    data?: CinemaDTO;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: ICinemaDTOAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? CinemaDTO.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): CinemaDTOAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CinemaDTOAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface ICinemaDTOAPIResponse {
    success?: boolean;
    data?: CinemaDTO;
    message?: string | null;
    errorMessage?: string | null;
}

export class CinemaDTOIEnumerableAPIResponse implements ICinemaDTOIEnumerableAPIResponse {
    success?: boolean;
    data?: CinemaDTO[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: ICinemaDTOIEnumerableAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CinemaDTO.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): CinemaDTOIEnumerableAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CinemaDTOIEnumerableAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface ICinemaDTOIEnumerableAPIResponse {
    success?: boolean;
    data?: CinemaDTO[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class DateOnly implements IDateOnly {
    year?: number;
    month?: number;
    day?: number;
    dayOfWeek?: DayOfWeek;
    readonly dayOfYear?: number;
    readonly dayNumber?: number;

    constructor(data?: IDateOnly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"] !== undefined ? _data["year"] : <any>null;
            this.month = _data["month"] !== undefined ? _data["month"] : <any>null;
            this.day = _data["day"] !== undefined ? _data["day"] : <any>null;
            this.dayOfWeek = _data["dayOfWeek"] !== undefined ? _data["dayOfWeek"] : <any>null;
            (<any>this).dayOfYear = _data["dayOfYear"] !== undefined ? _data["dayOfYear"] : <any>null;
            (<any>this).dayNumber = _data["dayNumber"] !== undefined ? _data["dayNumber"] : <any>null;
        }
    }

    static fromJS(data: any): DateOnly {
        data = typeof data === 'object' ? data : {};
        let result = new DateOnly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year !== undefined ? this.year : <any>null;
        data["month"] = this.month !== undefined ? this.month : <any>null;
        data["day"] = this.day !== undefined ? this.day : <any>null;
        data["dayOfWeek"] = this.dayOfWeek !== undefined ? this.dayOfWeek : <any>null;
        data["dayOfYear"] = this.dayOfYear !== undefined ? this.dayOfYear : <any>null;
        data["dayNumber"] = this.dayNumber !== undefined ? this.dayNumber : <any>null;
        return data;
    }
}

export interface IDateOnly {
    year?: number;
    month?: number;
    day?: number;
    dayOfWeek?: DayOfWeek;
    dayOfYear?: number;
    dayNumber?: number;
}

export enum DayOfWeek {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class GenreDTO implements IGenreDTO {
    genreId?: number;
    name?: string | null;
    movie?: MovieDto;

    constructor(data?: IGenreDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.genreId = _data["genreId"] !== undefined ? _data["genreId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.movie = _data["movie"] ? MovieDto.fromJS(_data["movie"]) : <any>null;
        }
    }

    static fromJS(data: any): GenreDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GenreDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["genreId"] = this.genreId !== undefined ? this.genreId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["movie"] = this.movie ? this.movie.toJSON() : <any>null;
        return data;
    }
}

export interface IGenreDTO {
    genreId?: number;
    name?: string | null;
    movie?: MovieDto;
}

export class GenreDTOAPIResponse implements IGenreDTOAPIResponse {
    success?: boolean;
    data?: GenreDTO;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IGenreDTOAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? GenreDTO.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): GenreDTOAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GenreDTOAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IGenreDTOAPIResponse {
    success?: boolean;
    data?: GenreDTO;
    message?: string | null;
    errorMessage?: string | null;
}

export class GenreDTOIEnumerableAPIResponse implements IGenreDTOIEnumerableAPIResponse {
    success?: boolean;
    data?: GenreDTO[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IGenreDTOIEnumerableAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GenreDTO.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): GenreDTOIEnumerableAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GenreDTOIEnumerableAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IGenreDTOIEnumerableAPIResponse {
    success?: boolean;
    data?: GenreDTO[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class MovieDto implements IMovieDto {
    movieId?: number;
    title?: string | null;
    releaseDate?: DateOnly;
    duration?: number | null;
    rating?: number | null;
    genre?: GenreDTO;
    description?: string | null;

    constructor(data?: IMovieDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.movieId = _data["movieId"] !== undefined ? _data["movieId"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.releaseDate = _data["releaseDate"] ? DateOnly.fromJS(_data["releaseDate"]) : <any>null;
            this.duration = _data["duration"] !== undefined ? _data["duration"] : <any>null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : <any>null;
            this.genre = _data["genre"] ? GenreDTO.fromJS(_data["genre"]) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): MovieDto {
        data = typeof data === 'object' ? data : {};
        let result = new MovieDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["movieId"] = this.movieId !== undefined ? this.movieId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toJSON() : <any>null;
        data["duration"] = this.duration !== undefined ? this.duration : <any>null;
        data["rating"] = this.rating !== undefined ? this.rating : <any>null;
        data["genre"] = this.genre ? this.genre.toJSON() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IMovieDto {
    movieId?: number;
    title?: string | null;
    releaseDate?: DateOnly;
    duration?: number | null;
    rating?: number | null;
    genre?: GenreDTO;
    description?: string | null;
}

export class MovieDtoAPIResponse implements IMovieDtoAPIResponse {
    success?: boolean;
    data?: MovieDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IMovieDtoAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? MovieDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): MovieDtoAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MovieDtoAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IMovieDtoAPIResponse {
    success?: boolean;
    data?: MovieDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class MovieDtoIEnumerableAPIResponse implements IMovieDtoIEnumerableAPIResponse {
    success?: boolean;
    data?: MovieDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IMovieDtoIEnumerableAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MovieDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): MovieDtoIEnumerableAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MovieDtoIEnumerableAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IMovieDtoIEnumerableAPIResponse {
    success?: boolean;
    data?: MovieDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class PaymentDTO implements IPaymentDTO {
    paymentId?: number;
    ticketId?: number;
    amount?: number;

    constructor(data?: IPaymentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"] !== undefined ? _data["paymentId"] : <any>null;
            this.ticketId = _data["ticketId"] !== undefined ? _data["ticketId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
        }
    }

    static fromJS(data: any): PaymentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId !== undefined ? this.paymentId : <any>null;
        data["ticketId"] = this.ticketId !== undefined ? this.ticketId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        return data;
    }
}

export interface IPaymentDTO {
    paymentId?: number;
    ticketId?: number;
    amount?: number;
}

export class PaymentDTOAPIResponse implements IPaymentDTOAPIResponse {
    success?: boolean;
    data?: PaymentDTO;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IPaymentDTOAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? PaymentDTO.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): PaymentDTOAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDTOAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IPaymentDTOAPIResponse {
    success?: boolean;
    data?: PaymentDTO;
    message?: string | null;
    errorMessage?: string | null;
}

export class PaymentDTOIEnumerableAPIResponse implements IPaymentDTOIEnumerableAPIResponse {
    success?: boolean;
    data?: PaymentDTO[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IPaymentDTOIEnumerableAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PaymentDTO.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): PaymentDTOIEnumerableAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDTOIEnumerableAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IPaymentDTOIEnumerableAPIResponse {
    success?: boolean;
    data?: PaymentDTO[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class ReviewDto implements IReviewDto {
    reviewId?: number;
    userId?: number;
    movieId?: number;
    rating?: number;
    reviewText?: string | null;

    constructor(data?: IReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reviewId = _data["reviewId"] !== undefined ? _data["reviewId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.movieId = _data["movieId"] !== undefined ? _data["movieId"] : <any>null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : <any>null;
            this.reviewText = _data["reviewText"] !== undefined ? _data["reviewText"] : <any>null;
        }
    }

    static fromJS(data: any): ReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewId"] = this.reviewId !== undefined ? this.reviewId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["movieId"] = this.movieId !== undefined ? this.movieId : <any>null;
        data["rating"] = this.rating !== undefined ? this.rating : <any>null;
        data["reviewText"] = this.reviewText !== undefined ? this.reviewText : <any>null;
        return data;
    }
}

export interface IReviewDto {
    reviewId?: number;
    userId?: number;
    movieId?: number;
    rating?: number;
    reviewText?: string | null;
}

export class ReviewDtoAPIResponse implements IReviewDtoAPIResponse {
    success?: boolean;
    data?: ReviewDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IReviewDtoAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? ReviewDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ReviewDtoAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDtoAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IReviewDtoAPIResponse {
    success?: boolean;
    data?: ReviewDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class ReviewDtoIEnumerableAPIResponse implements IReviewDtoIEnumerableAPIResponse {
    success?: boolean;
    data?: ReviewDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IReviewDtoIEnumerableAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ReviewDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ReviewDtoIEnumerableAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDtoIEnumerableAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IReviewDtoIEnumerableAPIResponse {
    success?: boolean;
    data?: ReviewDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class RoleDto implements IRoleDto {
    roleId?: number;
    roleName?: string | null;
    user?: UserDTO;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
            this.user = _data["user"] ? UserDTO.fromJS(_data["user"]) : <any>null;
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        return data;
    }
}

export interface IRoleDto {
    roleId?: number;
    roleName?: string | null;
    user?: UserDTO;
}

export class RoleDtoAPIResponse implements IRoleDtoAPIResponse {
    success?: boolean;
    data?: RoleDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IRoleDtoAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? RoleDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): RoleDtoAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IRoleDtoAPIResponse {
    success?: boolean;
    data?: RoleDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class RoleDtoIEnumerableAPIResponse implements IRoleDtoIEnumerableAPIResponse {
    success?: boolean;
    data?: RoleDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IRoleDtoIEnumerableAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RoleDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): RoleDtoIEnumerableAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoIEnumerableAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IRoleDtoIEnumerableAPIResponse {
    success?: boolean;
    data?: RoleDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class ShowTimeDTO implements IShowTimeDTO {
    showtimeId?: number;
    cinemaId?: number;
    movieId?: number;
    startTime?: Date;

    constructor(data?: IShowTimeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showtimeId = _data["showtimeId"] !== undefined ? _data["showtimeId"] : <any>null;
            this.cinemaId = _data["cinemaId"] !== undefined ? _data["cinemaId"] : <any>null;
            this.movieId = _data["movieId"] !== undefined ? _data["movieId"] : <any>null;
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): ShowTimeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ShowTimeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showtimeId"] = this.showtimeId !== undefined ? this.showtimeId : <any>null;
        data["cinemaId"] = this.cinemaId !== undefined ? this.cinemaId : <any>null;
        data["movieId"] = this.movieId !== undefined ? this.movieId : <any>null;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>null;
        return data;
    }
}

export interface IShowTimeDTO {
    showtimeId?: number;
    cinemaId?: number;
    movieId?: number;
    startTime?: Date;
}

export class ShowTimeDTOAPIResponse implements IShowTimeDTOAPIResponse {
    success?: boolean;
    data?: ShowTimeDTO;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IShowTimeDTOAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? ShowTimeDTO.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ShowTimeDTOAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ShowTimeDTOAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IShowTimeDTOAPIResponse {
    success?: boolean;
    data?: ShowTimeDTO;
    message?: string | null;
    errorMessage?: string | null;
}

export class ShowTimeDTOIEnumerableAPIResponse implements IShowTimeDTOIEnumerableAPIResponse {
    success?: boolean;
    data?: ShowTimeDTO[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IShowTimeDTOIEnumerableAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ShowTimeDTO.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ShowTimeDTOIEnumerableAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ShowTimeDTOIEnumerableAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IShowTimeDTOIEnumerableAPIResponse {
    success?: boolean;
    data?: ShowTimeDTO[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class TicketDto implements ITicketDto {
    ticketId?: number;
    price?: number;
    showtimeId?: number;
    showtime?: ShowTimeDTO;

    constructor(data?: ITicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticketId = _data["ticketId"] !== undefined ? _data["ticketId"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.showtimeId = _data["showtimeId"] !== undefined ? _data["showtimeId"] : <any>null;
            this.showtime = _data["showtime"] ? ShowTimeDTO.fromJS(_data["showtime"]) : <any>null;
        }
    }

    static fromJS(data: any): TicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketId"] = this.ticketId !== undefined ? this.ticketId : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["showtimeId"] = this.showtimeId !== undefined ? this.showtimeId : <any>null;
        data["showtime"] = this.showtime ? this.showtime.toJSON() : <any>null;
        return data;
    }
}

export interface ITicketDto {
    ticketId?: number;
    price?: number;
    showtimeId?: number;
    showtime?: ShowTimeDTO;
}

export class TicketDtoAPIResponse implements ITicketDtoAPIResponse {
    success?: boolean;
    data?: TicketDto;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: ITicketDtoAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? TicketDto.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): TicketDtoAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDtoAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface ITicketDtoAPIResponse {
    success?: boolean;
    data?: TicketDto;
    message?: string | null;
    errorMessage?: string | null;
}

export class TicketDtoIEnumerableAPIResponse implements ITicketDtoIEnumerableAPIResponse {
    success?: boolean;
    data?: TicketDto[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: ITicketDtoIEnumerableAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TicketDto.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): TicketDtoIEnumerableAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDtoIEnumerableAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface ITicketDtoIEnumerableAPIResponse {
    success?: boolean;
    data?: TicketDto[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class UserDTO implements IUserDTO {
    userId?: number;
    name?: string | null;
    email?: string | null;
    password?: string | null;
    createdAt?: string | null;

    constructor(data?: IUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.createdAt = _data["createdAt"] !== undefined ? _data["createdAt"] : <any>null;
        }
    }

    static fromJS(data: any): UserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["createdAt"] = this.createdAt !== undefined ? this.createdAt : <any>null;
        return data;
    }
}

export interface IUserDTO {
    userId?: number;
    name?: string | null;
    email?: string | null;
    password?: string | null;
    createdAt?: string | null;
}

export class UserDTOAPIResponse implements IUserDTOAPIResponse {
    success?: boolean;
    data?: UserDTO;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IUserDTOAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.data = _data["data"] ? UserDTO.fromJS(_data["data"]) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): UserDTOAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTOAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IUserDTOAPIResponse {
    success?: boolean;
    data?: UserDTO;
    message?: string | null;
    errorMessage?: string | null;
}

export class UserDTOIEnumerableAPIResponse implements IUserDTOIEnumerableAPIResponse {
    success?: boolean;
    data?: UserDTO[] | null;
    message?: string | null;
    errorMessage?: string | null;

    constructor(data?: IUserDTOIEnumerableAPIResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDTO.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
        }
    }

    static fromJS(data: any): UserDTOIEnumerableAPIResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTOIEnumerableAPIResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        return data;
    }
}

export interface IUserDTOIEnumerableAPIResponse {
    success?: boolean;
    data?: UserDTO[] | null;
    message?: string | null;
    errorMessage?: string | null;
}

export class UserRequestDto implements IUserRequestDto {
    username?: string | null;
    password?: string | null;

    constructor(data?: IUserRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): UserRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IUserRequestDto {
    username?: string | null;
    password?: string | null;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}